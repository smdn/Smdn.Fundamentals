# SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: "2022 smdn <smdn@smdn.jp>"

name: Publish release target (reusable workflow)

on:
  workflow_call:
    inputs:
      pr_number_request_for_release:
        description: "The number of pull request that requests to merge the release working branch."
        required: true
        type: number

      dry_run:
        description: "If true, performs a trial run."
        required: false
        type: boolean
        default: false

    secrets:
      token_repo:
        description: 'The token which is used to checkout code, view pull request of release target, download artifact from the precedent workflow, and create a new release.'
        required: true

      token_push_nuget_org:
        description: 'The token which is used to push a package to nuget.org.'
        required: false

      token_push_github_packages:
        description: 'The token which is used to push a package to GitHub Packages.'
        required: false

env:
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  DOTNET_NOLOGO: true

jobs:
  publish-release-target:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      # note: checkout repository firstly due to working directory will be cleaned up on checkout
      uses: actions/checkout@v2.4.0
      with:
        token: ${{ secrets.token_repo }}
        persist-credentials: true

    - name: Configure git identity
      run: |
        git config user.name github-actions
        git config user.email github-actions@github.com

        # TODO
        # git config user.name '${{ github.repository_owner }}'
        # git config user.email '<>'

    - name: Determine release target information
      id: release-info
      env:
        GH_TOKEN: ${{ secrets.token_repo }}
      shell: pwsh
      run: |
        $release_pr_body = gh pr view `
          ${{ inputs.pr_number_request_for_release }} `
          --repo ${{ github.repository }} `
          --json body `
          --template '{{.body}}'

        if ("$release_pr_body" -match ([regex]::escape('/${{ github.repository }}/actions/runs/') + '(?<run_id>[0-9]+)')) {
          $precedent_workflow_run_id = $Matches['run_id']
        }
        else {
          "::error::precedent workflow run id could not be determined."
          exit 1
        }

        $release_target_infoes = (
          $release_pr_body |
          Select-String -Pattern '(?m)^\- (?<key>[a-z_]+)\: \[?`(?<value>[^`]+)`\]?.*$' -AllMatches
        ).Matches
        $release_info_dict = [System.Collections.Generic.Dictionary[String, String]]::new()

        foreach ($pair in $release_target_infoes) {
          if ( ! $release_info_dict.ContainsKey($pair.Groups['key'].Value) ) {
            # stores the first value found
            $release_info_dict[$pair.Groups['key'].Value] = $pair.Groups['value'].Value
          }
        }

        [string]$package_target_tag = $null
        [string]$package_id = $null
        [string]$package_id_with_version = $null
        [string]$package_version = $null
        [string]$package_branch = $null
        [string]$release_working_branch = $null
        [string]$release_tag = $null
        [string]$release_draft = $null
        [string]$release_note_url = $null

        if ( ! $release_info_dict.TryGetValue( "package_target_tag", [ref]$package_target_tag ) ) {
          "::error::package_target_tag could not be determined."
          exit 1
        }
        if ( ! $release_info_dict.TryGetValue( "package_id", [ref]$package_id ) ) {
          "::error::package_id could not be determined."
          exit 1
        }
        if ( ! $release_info_dict.TryGetValue( "package_id_with_version", [ref]$package_id_with_version ) ) {
          "::error::package_id_with_version could not be determined."
          exit 1
        }
        if ( ! $release_info_dict.TryGetValue( "package_version", [ref]$package_version ) ) {
          "::error::package_version could not be determined."
          exit 1
        }
        if ( ! $release_info_dict.TryGetValue( "package_branch", [ref]$package_branch ) ) {
          "::error::package_branch could not be determined."
          exit 1
        }
        if ( ! $release_info_dict.TryGetValue( "release_working_branch", [ref]$release_working_branch ) ) {
          "::error::release_working_branch could not be determined."
          exit 1
        }
        if ( ! $release_info_dict.TryGetValue( "release_tag", [ref]$release_tag ) ) {
          "::error::release_tag could not be determined."
          exit 1
        }
        if ( ! $release_info_dict.TryGetValue( "release_draft", [ref]$release_draft ) ) {
          # if value is not explicitly specified, create release as a draft
          $release_draft = "true"
        }
        if ( ! $release_info_dict.TryGetValue( "release_note_url", [ref]$release_note_url ) ) {
          "::error::release_note_url could not be determined."
          exit 1
        }

        # notice determined info
        "::notice::package_target_tag=${package_target_tag}"
        "::notice::package_id=${package_id}"
        "::notice::package_id_with_version=${package_id_with_version}"
        "::notice::package_version=${package_version}"
        "::notice::package_branch=${package_branch}"
        "::notice::release_working_branch=${release_working_branch}"
        "::notice::release_tag=${release_tag}"
        "::notice::release_draft=${release_draft}"
        "::notice::release_note_url=${release_note_url}"
        "::notice::precedent_workflow_run_id=${precedent_workflow_run_id}"

        # set outputs
        "::set-output name=package_target_tag::${package_target_tag}"
        "::set-output name=package_id::${package_id}"
        "::set-output name=package_id_with_version::${package_id_with_version}"
        "::set-output name=package_version::${package_version}"
        "::set-output name=package_branch::${package_branch}"
        "::set-output name=release_working_branch::${release_working_branch}"
        "::set-output name=release_tag::${release_tag}"
        "::set-output name=release_draft::${release_draft}"
        "::set-output name=release_note_url::${release_note_url}"
        "::set-output name=precedent_workflow_run_id::${precedent_workflow_run_id}"

        [string]$artifact_name_nupkg = $null

        if ( $release_info_dict.TryGetValue( "artifact_name_nupkg", [ref] $artifact_name_nupkg ) ) {
          "::notice::artifact_name_nupkg=${artifact_name_nupkg}"

          "::set-output name=artifact_name_nupkg::${artifact_name_nupkg}"
        }
        else {
          '::notice::No packages will be published.'
        }

        # check working and package branch
        $ref_names = gh pr view `
          ${{ inputs.pr_number_request_for_release }} `
          --repo ${{ github.repository }} `
          --json baseRefName,headRefName `
          --template '{{.baseRefName}} {{.headRefName}}'

        $ref_name_base = ($ref_names -split ' ')[0]
        $ref_name_head = ($ref_names -split ' ')[1]

        if ( $release_working_branch -ne $ref_name_head ) {
          "::error::expected working branch is '${release_working_branch}' but was '${ref_name_head}'."
          exit 1
        }
        if ( $package_branch -ne $ref_name_base ) {
          "::error::expected package branch is '${package_branch}' but was '${ref_name_base}'."
          exit 1
        }

    - name: Download package ${{ steps.release-info.outputs.artifact_name_nupkg }}
      if: ${{ steps.release-info.outputs.artifact_name_nupkg != '' }}
      uses: dawidd6/action-download-artifact@v2.17.0
      with:
        github_token: ${{ secrets.token_repo }}
        workflow: generate-release-target.yml
        run_id:  ${{ steps.release-info.outputs.precedent_workflow_run_id }}
        name: ${{ steps.release-info.outputs.artifact_name_nupkg }}

    - name: Publish package ${{ steps.release-info.outputs.artifact_name_nupkg }} to nuget.org
      id: push-nuget-org
      if: ${{ !inputs.dry_run && env.NUGET_APIKEY != null }}
      env:
        NUGET_APIKEY: ${{ secrets.token_push_nuget_org }}
        NUGET_SOURCE: 'https://api.nuget.org/v3/index.json'
      run: |
        if [[ -z '${{ steps.release-info.outputs.artifact_name_nupkg }}' ]]; then
          echo "::notice::No packages was pushed to '$NUGET_SOURCE'."
        else
          dotnet nuget push \
            --api-key $NUGET_APIKEY \
            --source $NUGET_SOURCE \
            '${{ steps.release-info.outputs.artifact_name_nupkg }}'

          echo "::set-output name=pushed::true"
          echo "::notice::The package '${{ steps.release-info.outputs.artifact_name_nupkg }}' was pushed to '$NUGET_SOURCE' successfully."
        fi

    - name: Publish package ${{ steps.release-info.outputs.artifact_name_nupkg }} to GitHub packages
      id: push-github-packages
      if: ${{ !inputs.dry_run && env.NUGET_APIKEY != null }}
      env:
        NUGET_APIKEY: ${{ secrets.token_push_github_packages }}
        NUGET_SOURCE: 'https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json'
      run: |
        if [[ -z '${{ steps.release-info.outputs.artifact_name_nupkg }}' ]]; then
          echo "::notice::No packages was pushed to '$NUGET_SOURCE'."
        else
          dotnet nuget push \
            --api-key $NUGET_APIKEY \
            --source $NUGET_SOURCE \
            '${{ steps.release-info.outputs.artifact_name_nupkg }}'

          echo "::set-output name=pushed::true"
          echo "::notice::The package '${{ steps.release-info.outputs.artifact_name_nupkg }}' was pushed to '$NUGET_SOURCE' successfully."
        fi

    - name: Delete package ${{ steps.release-info.outputs.artifact_name_nupkg }}
      if: ${{ steps.release-info.outputs.artifact_name_nupkg != '' }}
      run: |
        rm -f ${{ steps.release-info.outputs.artifact_name_nupkg }}

    - name: Create release tag ${{ steps.release-info.outputs.release_tag }}
      run: |
        git tag \
          --annotate \
          '${{ steps.release-info.outputs.release_tag }}' \
          -m '${{ steps.release-info.outputs.package_branch }}/${{ steps.release-info.outputs.package_id_with_version }}'

        if [[ '${{ inputs.dry_run }}' != 'true' ]]; then
          git push origin '${{ steps.release-info.outputs.release_tag }}'
        fi

    - name: Create release notes file for ${{ steps.release-info.outputs.release_tag }}
      id: release-notes-file
      env:
        GH_TOKEN: ${{ secrets.token_repo }}
      shell: pwsh
      run: |
        $dry_run = '${{ inputs.dry_run }}' -ieq 'true'

        # note: the maximum size of the release body seems to be 125,000 characters (textarea#release_body@data-input-max-length="125000")
        $release_notes_body_max_length = 125000
        $release_notes_body = New-Object System.Text.StringBuilder -ArgumentList 10240
        $release_notes_output_path = [System.IO.Path]::GetFullPath('releasenotes.md')

        if ( '${{ steps.push-nuget-org.outputs.pushed }}' -ieq 'true' -Or $dry_run ) {
          [void]$release_notes_body.AppendLine('# Released package')
          [void]$release_notes_body.AppendFormat(
            '- NuGet [{0} version {1}](https://www.nuget.org/packages/{0}/{1})',
            '${{ steps.release-info.outputs.package_id }}',
            '${{ steps.release-info.outputs.package_version }}'
          ).AppendLine()
          [void]$release_notes_body.AppendLine()
        }

        #
        # Downloads release note files from gist and attempts to append them to release notes.
        # If the body exceeds the maximum length when appended, will cancel appending.
        #
        [void]$release_notes_body.AppendLine('# Release notes')
        [void]$release_notes_body.AppendLine('The [full release notes](${{ steps.release-info.outputs.release_note_url }}) are available at gist.')
        [void]$release_notes_body.AppendLine()

        $release_note_sections = @(
          [PSCustomObject]@{
            FileNameSuffix = '.changelog.md'
            Title = 'Change log'
            Header = $([String]::Join(
              "`n",
              @(
                '<details>'
                '<summary>Change log in this release:</summary>'
                '<div>'
                ''
              )
            ))
            Footer = $([String]::Join(
              "`n",
              @(
                ''
                '</div>'
                '</details>'
              )
            ))
          }
          [PSCustomObject]@{
            FileNameSuffix = '.api-changes.diff'
            Title = 'API changes'
            Header = $([String]::Join(
              "`n",
              @(
                '<details>'
                '<summary>API changes in this release:</summary>'
                '<div>'
                ''
                '```diff'
              )
            ))
            Footer = $([String]::Join(
              "`n",
              @(
                '```'
                ''
                '</div>'
                '</details>'
              )
            ))
          }
          [PSCustomObject]@{
            FileNameSuffix = '.full-changes.diff'
            Title = 'Full changes'
            Header = $([String]::Join(
              "`n",
              @(
                '<details>'
                '<summary>Full changes in this release:</summary>'
                '<div>'
                ''
                '```diff'
              )
            ))
            Footer = $([String]::Join(
              "`n",
              @(
                '```'
                ''
                '</div>'
                '</details>'
              )
            ))
          }
        )

        # list release note files from gist
        $release_note_files = gh gist view `
          '${{ steps.release-info.outputs.release_note_url }}' `
          --files

        # download release note files
        foreach ( $section in $release_note_sections ) {
          $release_note_file = $release_note_files |
            where { $_.StartsWith('releasenote.') -And $_.EndsWith($section.FileNameSuffix) } |
            select -First 1

          if ( ! $release_note_file ) {
            continue
          }

          $release_note_content = gh gist view `
            '${{ steps.release-info.outputs.release_note_url }}' `
            --raw `
            --filename $release_note_file

          $section
            | Add-Member `
            -MemberType NoteProperty `
            -Name 'Content' `
            -Value $release_note_content
        }

        # construct release note section
        foreach ( $section in $release_note_sections ) {
          if ( [string]::IsNullOrEmpty( $section.Content ) ) {
            continue
          }

          $section_body = New-Object System.Text.StringBuilder -ArgumentList 10240

          [void]$section_body.AppendLine("## $($section.Title)")
          [void]$section_body.AppendLine($section.Header)
          [void]$section_body.AppendLine($section.Content -join "`n")
          [void]$section_body.AppendLine($section.Footer)
          [void]$section_body.AppendLine()

          # attempt to append constructed section
          if ( $release_notes_body_max_length -lt $release_notes_body.Length + $section_body.Length ) {
            break;
          }

          [void]$release_notes_body.Append($section_body.ToString())
        }

        # write release notes file
        if ( $dry_run ) {
          $release_notes_body.ToString()
        }
        else {
          Out-File -FilePath $release_notes_output_path -Encoding utf8 -InputObject $release_notes_body.ToString()

          "::notice::Create release notes file: '${release_notes_output_path}' ($($release_notes_body.Length) characters)"
        }

        # set outputs
        "::set-output name=path::${release_notes_output_path}"

    - name: Create release notes for ${{ steps.release-info.outputs.release_tag }}
      env:
        GH_TOKEN: ${{ secrets.token_repo }}
      shell: pwsh
      run: |
        $dry_run = '${{ inputs.dry_run }}' -ieq 'true'

        $release_notes_file = '${{ steps.release-notes-file.outputs.path }}'
        $release_title = '${{ steps.release-info.outputs.package_id }} version ${{ steps.release-info.outputs.package_version }}'

        $release_create_options = @(
          '--repo', '${{ github.repository }}',
          '--title', $release_title,
          '--target', '${{ steps.release-info.outputs.package_branch }}',
          '--generate-notes',
          '--notes-file', $release_notes_file,
          ('${{ steps.release-info.outputs.release_draft }}' -ieq 'True' ? '--draft' : ''),
          '${{ steps.release-info.outputs.release_tag }}'
        )

        "gh release create ${release_create_options}"

        if ( $dry_run ) {
          $release_url = '(dry-run)'
        }
        else {
          $release_url = gh release create $release_create_options
        }

        "::notice::Created release '${release_title}': ${release_url}"

    - name: Delete release target tag ${{ steps.release-info.outputs.package_target_tag }}
      if: ${{ !inputs.dry_run }}
      run: git push origin --delete '${{ steps.release-info.outputs.package_target_tag }}' || true

    - name: Close release working branch ${{ steps.release-info.outputs.release_working_branch }}
      if: ${{ !inputs.dry_run }}
      run: git push origin --delete '${{ steps.release-info.outputs.release_working_branch }}' || true
