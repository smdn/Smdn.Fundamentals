# SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: "2022 smdn <smdn@smdn.jp>"

name: Generate release target (reusable workflow)

on:
  workflow_call:
    inputs:
      release_target_tag_name:
        description: "The tag name of the release target."
        required: true
        type: string

      release_target_tag_prefix:
        description: "The common prefix of the release target tag name."
        required: false
        type: string
        default: "new-release/"

      release_target_pr_label:
        description: "The label to set for the pull request of the release target"
        required: false
        type: string
        default: "release-target"

      release_tag_prefix:
        description: "The common prefix of the release tag name."
        required: false
        type: string
        default: "releases/"

      path_prefix_source:
        description: "The common prefix of the path to source directory of the release target based on the repository root."
        required: false
        type: string
        default: "src/"

      path_prefix_apilist:
        description: "The common prefix of the path to API list directory of the release target based on the repository root."
        required: false
        type: string
        default: "doc/api-list/"

      dry_run:
        description: "If true, performs a trial run."
        required: false
        type: boolean
        default: false

    secrets:
      token_repo:
        description: 'The token which is used to checkout code.'
        required: true

      token_pullrequest:
        description: 'The token which is used to open a pull request for the new release.'
        required: true

      token_gist:
        description: 'The token which is used to create release notes onto gist.'
        required: true

env:
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  DOTNET_NOLOGO: true

jobs:
  generate-release-target:
    runs-on: ubuntu-latest
    if: startsWith(inputs.release_target_tag_name, inputs.release_target_tag_prefix)

    steps:
    - name: Checkout repository
      uses: actions/checkout@v2.4.0
      with:
        # TODO: attempt treeless clone '--filter=tree:0'
        # ref: https://github.blog/2020-12-21-get-up-to-speed-with-partial-clone-and-shallow-clone/
        fetch-depth: 0
        ref: ${{ inputs.release_target_tag_name }}
        token: ${{ secrets.token_repo }}
        persist-credentials: true

    - name: Configure git identity
      run: |
        git config user.name github-actions
        git config user.email github-actions@github.com

        # TODO
        # git config user.name '${{ github.repository_owner }}'
        # git config user.email '<>'

    - name: Determine the release target package information
      id: package-info
      # note: Parse and determines parse package info from the triggered tag name.
      # note: The tag name must be in format of '<prefix>/<branch>/Package.ID-1.2.3-prerelease'.
      # note: The tag that ends with '-unreleased' will be treated as an unreleasable target where nupkg will not be uploaded.
      shell: pwsh
      run: |
        $pattern_target_tag = '^{0}{1}{2}\-{3}(\-{4})?$' -f
          '${{ inputs.release_target_tag_prefix }}',
          '(?<branch>[A-Za-z0-9\.\-]+)/',
          '(?<id>[A-Za-z0-9\.]+)',
          '(?<version>[0-9]+\.[0-9]+\.[0-9]+(\.[0-9]+)?([\-\+][0-9a-zA-Z\.]+)?)',
          '(?<suffix>[A-Za-z0-9]+)'

        $package_target_tag = '${{ inputs.release_target_tag_name }}'

        if ("$package_target_tag" -match "$pattern_target_tag") {
          # split package info and version from tag name
          $package_branch = $Matches['branch']
          $package_id = $Matches['id']
          $package_version = $Matches['version']
          $package_id_with_version = '{0}-{1}' -f $package_id, $package_version
          $package_source_dir = '${{ inputs.path_prefix_source }}{0}/' -f $package_id

          if ( -not ( Test-Path -Path $package_source_dir -PathType Container ) ) {
            "::error::The source directory '${package_source_dir}' was not found.  Make sure that the tag name '${package_target_tag}' indicates a package which is present."
            exit 1
          }

          # treat the version ends with '-unreleased' as an unreleasable package
          $package_can_release = $Matches['suffix'] -ne "-unreleased"

          # notice determined info
          "::notice::package_target_tag=${package_target_tag}"
          "::notice::package_branch=${package_branch}"
          "::notice::package_can_release=${package_can_release}"
          "::notice::package_id=${package_id}"
          "::notice::package_id_with_version=${package_id_with_version}"
          "::notice::package_version=${package_version}"
          "::notice::package_source_dir=${package_source_dir}"

          # set outputs
          "::set-output name=package_target_tag::${package_target_tag}"
          "::set-output name=package_branch::${package_branch}"
          "::set-output name=package_can_release::${package_can_release}"
          "::set-output name=package_id::${package_id}"
          "::set-output name=package_id_with_version::${package_id_with_version}"
          "::set-output name=package_version::${package_version}"
          "::set-output name=package_source_dir::${package_source_dir}"
        }
        else {
          "::error::tag name format mismatch: $package_target_tag"
          exit 1
        }

        # find the tag of the previous version
        $package_prevver_ref = git describe --tags --abbrev=0 --match "${{ inputs.release_tag_prefix }}${package_id}-*"

        if ( -not $package_prevver_ref ) {
          "::warning::could not find a tag of the previous version"

          # refer initial commit as previous version instead
          $package_prevver_ref = git rev-list HEAD | tail -1
        }

        "::notice::package_prevver_ref=${package_prevver_ref}"
        "::set-output name=package_prevver_ref::${package_prevver_ref}"

    - name: Determine the release info of ${{ steps.package-info.outputs.package_id_with_version }}
      id: release-info
      shell: pwsh
      run: |
        $release_tag = '${{ inputs.release_tag_prefix }}${{ steps.package-info.outputs.package_id_with_version }}'
        $release_working_branch = "${release_tag}-$([DateTimeOffset]::UtcNow.ToUnixTimeSeconds().ToString("D"))"

        # notice determined info
        '::notice::tag=${release_tag}'
        '::notice::working_branch=${release_working_branch}'

        # set outputs
        "::set-output name=tag::${release_tag}"
        "::set-output name=working_branch::${release_working_branch}"

    - name: Set NUGET_PACKAGES
      shell: pwsh
      run: |
        $dir_nuget_packages =[System.IO.Path]::Combine(
          '${{ github.workspace }}',
          '.nuget',
          'packages'
        )

        "::notice::NUGET_PACKAGES=${dir_nuget_packages}"

        "NUGET_PACKAGES=${dir_nuget_packages}" >> $Env:GITHUB_ENV

    - name: Setup NuGet cache
      # ref: https://github.com/actions/cache/blob/master/examples.md#c---nuget
      uses: actions/cache@v2
      with:
        path: ${{ env.NUGET_PACKAGES }}
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
        restore-keys: |
          ${{ runner.os }}-nuget-

    #- name: Setup .NET 6.0
    #  uses: actions/setup-dotnet@v1
    #  with:
    #    dotnet-version: '6.0.x'
    #    # include-prerelease: true
    - name: .NET info
      run: dotnet --info

    - name: Restore dependencies of ${{ steps.package-info.outputs.package_id }}
      shell: pwsh
      run: |
        # workaround for error on `dotnet restore`; The process cannot access the file '/home/runner/.nuget/NuGet/nugetorgadd.trk'
        # remove when https://github.com/NuGet/Home/issues/11607 is fixed
        # ref: https://github.com/EventStore/EventStore-Client-Dotnet/pull/201
        dotnet nuget list source

        dotnet restore `
          --nologo `
          ${{ steps.package-info.outputs.package_source_dir }}

    - name: Build ${{ steps.package-info.outputs.package_id }}
      shell: pwsh
      run: |
        dotnet build `
          --nologo `
          --no-restore `
          --configuration Release `
          -consoleLoggerParameters:NoSummary `
          /p:RepositoryBranch=${{ steps.package-info.outputs.package_branch }} `
          ${{ steps.package-info.outputs.package_source_dir }} `
        | Tee-Object -Variable build_log

        # select errors: 'path/to/file(line,col): error XX9999:'
        $build_errors = $build_log | Select-String -Pattern '\: error (?<error>[a-zA-Z0-9]+)\:' -AllMatches

        # select error codes: 'XX9999'
        $build_error_codes = $build_errors.Matches |
          Select-Object -Unique @{
            label='ErrorCode'
            expression={$_.Groups['error'].Value}
          }

        if ( 0 -lt ($build_error_codes).Count){
          "::error::build errors: $(($build_error_codes | Select-Object -ExpandProperty ErrorCode) -join ', ')"
        }

        # ignore the build error NETSDK1085; occurs if <NoBuild> is specified in project file.
        if ( 0 -lt ($build_error_codes | Where-Object -Property ErrorCode -NE 'NETSDK1085').Count ) {
          # build error occurred other than NETSDK1085
          exit 1
        }

        exit 0

    - name: Pack ${{ steps.package-info.outputs.package_id }}
      id: pack
      shell: pwsh
      run: |
        dotnet pack `
          --nologo `
          --configuration Release `
          --no-build `
          /p:RepositoryBranch=${{ steps.package-info.outputs.package_branch }} `
          ${{ steps.package-info.outputs.package_source_dir }}

        $file_nupkg  = '${{ steps.package-info.outputs.package_id }}.${{ steps.package-info.outputs.package_version }}.nupkg'
        $file_nuspec = '${{ steps.package-info.outputs.package_id }}.${{ steps.package-info.outputs.package_version }}.nuspec'

        $expected_nupkg  = "${{ steps.package-info.outputs.package_source_dir }}bin/Release/${file_nupkg}"
        $expected_nuspec = "${{ steps.package-info.outputs.package_source_dir }}obj/Release/${file_nuspec}"

        # test generated file
        if (
          ( Test-Path -Path $expected_nupkg  -PathType Leaf ) -and
          ( Test-Path -Path $expected_nuspec -PathType Leaf )
        ) {
          "::notice::package '${expected_nupkg}' was generated successfully"

          # set outputs
          "::set-output name=artifact_name_nupkg::${file_nupkg}"
          "::set-output name=path_nupkg::${expected_nupkg}"
          "::set-output name=path_nuspec::${expected_nuspec}"
        }
        else {
          "::error::'${expected_nupkg}' was not generated. Make sure that the Version/VersionPrefix/VersionSuffix in '${{ steps.package-info.outputs.package_id }}.csproj' are defined correctly."
          exit 1
        }

    - name: Upload ${{ steps.pack.outputs.artifact_name_nupkg }}
      if: ${{ steps.package-info.outputs.package_can_release == 'True' }}
      uses: actions/upload-artifact@v2
      with:
        name: ${{ steps.pack.outputs.artifact_name_nupkg }}
        path: ${{ steps.pack.outputs.path_nupkg }}
        retention-days: 1

    - name: Create release working branch for ${{ steps.package-info.outputs.package_id_with_version }}
      run: |
        # create release working branch from detached HEAD
        git checkout -b '${{ steps.release-info.outputs.working_branch }}'

        # attempt to add changes of API list
        if git add '${{ inputs.path_prefix_apilist }}${{ steps.package-info.outputs.package_id }}/*.apilist.cs'; then
          # commit API list changes to release working branch
          if git commit -m "update API list ${{ steps.package-info.outputs.package_id_with_version }}"; then
            HAS_COMMIT=true
          fi
        fi

        if [ -z "$HAS_COMMIT" ]; then
          echo "::notice::API list not generated or changed"

          # commit an empty commit instead. it is required to create pull request.
          git commit --allow-empty -m "create release branch for ${{ steps.package-info.outputs.package_id_with_version }}"
        fi

        # push release working branch to create pull request
        if [[ '${{ inputs.dry_run }}' != 'true' ]]; then
          git push origin ${{ steps.release-info.outputs.working_branch }}
        fi

    - name: Create extra release contents
      id: extra-release-contents
      shell: pwsh
      run: |
        # Target:
        #   "pullrequest": Is an extra content for the pull request. Will be added to pull request body.
        #   "releasenote": Is an extra content for the release note. Will be uploaded to gist for this release.
        $contents = @(
          [PSCustomObject]@{
            Title = ".nuspec"
            Target = "pullrequest"
            FileName = 'release-target.nuspec'
            Content = Get-Content -Path ${{ steps.pack.outputs.path_nuspec }}
          },
          [PSCustomObject]@{
            # this entry is expected to be shown as a gist's summary
            Title = '${{ steps.package-info.outputs.package_id_with_version }} Release Notes'
            Target = "releasenote"
            FileName = 'releasenote-${{ steps.package-info.outputs.package_id_with_version }}.md'
            Content = '${{ steps.package-info.outputs.package_branch }}/${{ steps.package-info.outputs.package_id_with_version }}'
          },
          [PSCustomObject]@{
            Title = "Change log"
            Target = "releasenote"
            FileName = 'releasenote.section1.changelog.md'
            Content = git log `
              ${{ steps.package-info.outputs.package_prevver_ref }}..HEAD `
              --pretty=format:'- %cs [%s](${{ github.server_url }}/${{ github.repository }}/commit/%H)' `
              -- `
              ${{ steps.package-info.outputs.package_source_dir }}
          },
          [PSCustomObject]@{
            Title = "API changes"
            Target = "releasenote"
            FileName = 'releasenote.section2.api-changes.diff'
            Content = git diff `
              --unified=10000 `
              ${{ github.sha }}..${{ steps.release-info.outputs.working_branch }} `
              -- `
              '${{ inputs.path_prefix_apilist }}${{ steps.package-info.outputs.package_id }}/'
          },
          [PSCustomObject]@{
            Title = "Full changes"
            Target = "releasenote"
            FileName = 'releasenote.section3.full-changes.diff'
            Content = git diff `
              --ignore-cr-at-eol `
              --ignore-space-at-eol `
              --ignore-all-space `
              --ignore-blank-lines `
              ${{ steps.package-info.outputs.package_prevver_ref }}..HEAD `
              -- `
              ${{ steps.package-info.outputs.package_source_dir }}
          }
        )

        foreach ($content in $contents) {
          if ( '${{ inputs.dry_run }}' -ieq 'true' ) {
            "########## $($content.Title) ###########"
            $content.Content
          }
          else {
            Out-File -FilePath $content.FileName -Encoding utf8 -InputObject $($content.Content -join "`n")

            $content | Add-Member -MemberType NoteProperty -Name 'IsWritten' -Value $true
          }
        }

        $contents_json = $contents | where IsWritten | select Title,FileName,Target | ConvertTo-Json -Compress

        "::notice::output: '${contents_json}'"

        # set outputs
        "::set-output name=contents::${contents_json}"

    - name: Create release note for ${{ steps.package-info.outputs.package_id_with_version }}
      id: releasenote
      shell: pwsh
      env:
        GH_TOKEN: ${{ secrets.token_gist }}
      run: |
        $description = '${{ steps.package-info.outputs.package_id }} ${{ steps.package-info.outputs.package_version }} Release Notes'
        $files = '${{ steps.extra-release-contents.outputs.contents }}' |
          ConvertFrom-Json |
          where Target -eq 'releasenote' |
          select -ExpandProperty FileName

        if ( $files.Count -le 0 ) {
          "::warning::could not create gist with empty files"
          exit 0
        }

        $url = gh gist create `
          --public `
          --desc "${description}" `
          @files

        if ( [string]::IsNullOrEmpty($url) ) {
          "::error::could not create gist '${description}'"
          exit 1
        }

        "::notice::Created gist '${description}': ${url}"

        # set outputs
        "::set-output name=url::${url}"

    - name: Create pull request from branch ${{ steps.release-info.outputs.working_branch }}
      id: pullrequest
      shell: pwsh
      env:
        GH_TOKEN: ${{ secrets.token_pullrequest }}
      run: |
        $dry_run = '${{ inputs.dry_run }}' -ieq 'true'
        $pr_title = 'Release ${{ steps.package-info.outputs.package_branch }}/${{ steps.package-info.outputs.package_id_with_version }}'

        #
        # construct pull request body
        # note: beware of changing output format on this section; these information will be parsed and referenced by subsequent workflows
        #
        $pr_body = New-Object System.Text.StringBuilder -ArgumentList 2048

        [void]$pr_body.AppendFormat(
          'Automatically generated by workflow [{0} #{1}]({2}).',
          '${{ github.workflow }}',
          '${{ github.run_number }}',
          '${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}'
        ).AppendLine()
        [void]$pr_body.AppendLine()

        [void]$pr_body.AppendLine('# Release target')
        [void]$pr_body.AppendLine('- package_target_tag: `${{ steps.package-info.outputs.package_target_tag }}`')
        [void]$pr_body.AppendLine('- package_id: `${{ steps.package-info.outputs.package_id }}`')
        [void]$pr_body.AppendLine('- package_id_with_version: `${{ steps.package-info.outputs.package_id_with_version }}`')
        [void]$pr_body.AppendLine('- package_version: `${{ steps.package-info.outputs.package_version }}`')
        [void]$pr_body.AppendLine('- package_branch: `${{ steps.package-info.outputs.package_branch }}`')
        [void]$pr_body.AppendLine('- release_working_branch: `${{ steps.release-info.outputs.working_branch }}`')
        [void]$pr_body.AppendLine('- release_tag: `${{ steps.release-info.outputs.tag }}`')
        [void]$pr_body.AppendLine('- release_draft: `false` ❗Change this value to `true` to create release note as draft.')
        [void]$pr_body.AppendLine('- release_note_url: [`${{ steps.releasenote.outputs.url }}`](${{ steps.releasenote.outputs.url }})')

        if ( '${{ steps.package-info.outputs.package_can_release }}' -ieq 'True' ) {
          [void]$pr_body.AppendLine('- artifact_name_nupkg: `${{ steps.pack.outputs.artifact_name_nupkg }}` ❗Remove this line or change this value to empty to prevent publishing packages.')
        }

        [void]$pr_body.AppendLine()

        # append extra contents
        $pr_body_contents = '${{ steps.extra-release-contents.outputs.contents }}' |
          ConvertFrom-Json |
          where Target -eq 'pullrequest'

        foreach ($content in $pr_body_contents) {
          $ext = [System.IO.Path]::GetExtension($($content.FileName)).TrimStart('.')

          [void]$pr_body.AppendLine("# $($content.Title)")

          [void]$pr_body.AppendLine('```' + $ext)
          [void]$pr_body.AppendLine($(Get-Content -Path $content.FileName) -join "`n")
          [void]$pr_body.AppendLine('```')
        }

        #
        # create pull request
        #
        $pr_body_file = [System.IO.Path]::GetFullPath('pr-body.md')

        if ( $dry_run ) {
          "================================================"
          $pr_body.ToString()
          "================================================"
        }
        else {
          Out-File -FilePath $pr_body_file -Encoding utf8 -InputObject $pr_body.ToString()
        }

        # ref: https://cli.github.com/manual/gh_pr_create
        $pr_create_options = @(
          '--base', '${{ steps.package-info.outputs.package_branch }}',
          '--head', '${{ steps.release-info.outputs.working_branch }}',
          '--assignee', '${{ github.repository_owner }}',
          '--no-maintainer-edit',
          '--title', $pr_title,
          '--body-file', $pr_body_file
        )

        if ( ! [string]::IsNullOrEmpty( '${{ inputs.release_target_pr_label }}' ) ) {
          $pr_create_options += @('--label', '${{ inputs.release_target_pr_label }}')
        }

        "gh pr create ${pr_create_options}"

        if ( $dry_run ) {
          $pr_url = "(dry-run)"
        }
        else {
          $pr_url = gh pr create $pr_create_options
        }

        if ( [string]::IsNullOrEmpty($pr_url) ) {
          "::error::could not create pull request for ${pr_title}"
          exit 1
        }

        "::notice::Created pull request for ${pr_title}: ${pr_url}"

        # set outputs
        "::set-output name=url::${pr_url}"
