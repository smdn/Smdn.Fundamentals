<!--
SPDX-FileCopyrightText: 2022 smdn <smdn@smdn.jp>
SPDX-License-Identifier: MIT
-->
<Project>
  <!--
    API list generator
  -->
  <PropertyGroup Condition=" '$(IsTestProject)' != 'true' " Label="Properties for the library project">
    <!-- API list default configurations -->
    <APIListEnableGenerating Condition=" '$(Configuration)' == 'Release' ">true</APIListEnableGenerating>
    <APIListOutputBaseDirectory Condition=" '$(APIListOutputBaseDirectory)' == '' ">api-list\</APIListOutputBaseDirectory>
    <APIListPackageVersion Condition=" '$(APIListPackageVersion)' == '' ">1.1.4</APIListPackageVersion>
    <APIListLoadIntoReflectionOnlyContext Condition=" '$(APIListLoadIntoReflectionOnlyContext)' == '' ">false</APIListLoadIntoReflectionOnlyContext>
  </PropertyGroup>

  <ItemGroup Label="API list generator" Condition=" '$(IsTestProject)' != 'true' ">
    <PackageReference
      Condition=" '$(APIListEnableGenerating)' == 'true' "
      Update="Smdn.Reflection.ReverseGenerating.ListApi.MSBuild.Tasks"
      Version="[$(APIListPackageVersion)]"
    />
    <PackageReference
      Condition=" '$(APIListEnableGenerating)' != 'true' "
      Remove="Smdn.Reflection.ReverseGenerating.ListApi.MSBuild.Tasks"
    />
  </ItemGroup>

  <PropertyGroup Label="API list generator" Condition="'$(APIListEnableGenerating)' == 'true'">
    <!-- This is required to import .props and .targets from Smdn.Reflection.ReverseGenerating.ListApi.MSBuild.Tasks -->
    <ExcludeRestorePackageImports>false</ExcludeRestorePackageImports>
  </PropertyGroup>

  <!--
    using task from local build assembly instead of tasks from Smdn.Reflection.ReverseGenerating.ListApi.MSBuild.Tasks package reference
    (consider using with `/nr:false`, see https://github.com/dotnet/msbuild/issues/7693)

  <UsingTask
    TaskName="GenerateApiList"
    AssemblyFile="/path/to/build/Smdn.Reflection.ReverseGenerating/src/Smdn.Reflection.ReverseGenerating.ListApi.MSBuild.Tasks/bin/Release/net6.0/Smdn.Reflection.ReverseGenerating.ListApi.MSBuild.Tasks.dll"
  />
  -->

  <!--
    PackageReadmeFile auto-generating
  -->
  <PropertyGroup Condition="'$(APIListEnableGenerating)' == 'true' and '$(GeneratePackageReadmeFile)' == 'true'">
    <PackageReadmeFile>README.md</PackageReadmeFile>
    <PackageReadmeFileOutputPath>$(OutputPath)$(PackageReadmeFile)</PackageReadmeFileOutputPath>
  </PropertyGroup>

  <ItemGroup Condition="'$(GeneratePackageReadmeFile)' == 'true'">
    <None Include="$(PackageReadmeFileOutputPath)" Pack="true" PackagePath="$(PackageReadmeFile)" />
  </ItemGroup>

  <Target
    Name="GenerateAPIListOfPackage"
    BeforeTargets="GenerateNuspec"
    Condition="'$(APIListEnableGenerating)' == 'true'"
    Label="API list generator"
  >
    <ItemGroup>
      <GenerateApiListTargets Include="%(NuGetPackInput.Identity)" Condition="
        '%(NuGetPackInput.MSBuildSourceProjectFile)' == '$(MSBuildProjectFullPath)' and
        '' != '%(NuGetPackInput.TargetFramework)' and
        $([System.String]::new('%(NuGetPackInput.TargetPath)').EndsWith('.dll'))
      ">
        <OutputFilePath>$(APIListOutputBaseDirectory)$(AssemblyName)\$(AssemblyName)-%(NuGetPackInput.TargetFramework).apilist.cs</OutputFilePath>
        <LoadIntoReflectionOnlyContext>$(APIListLoadIntoReflectionOnlyContext)</LoadIntoReflectionOnlyContext>
      </GenerateApiListTargets>
    </ItemGroup>

    <PropertyGroup Condition="'$(GenerateApiList_GenerateNullableAnnotations)' == ''">
      <GenerateApiList_GenerateNullableAnnotations>false</GenerateApiList_GenerateNullableAnnotations>
      <GenerateApiList_GenerateNullableAnnotations
        Condition="'$(Nullable)' == 'enable' or '$(Nullable)' == 'annotations'"
      >true</GenerateApiList_GenerateNullableAnnotations>
    </PropertyGroup>

    <GenerateApiList
      Assemblies="@(GenerateApiListTargets)"
      GenerateLanguagePrimitiveType="true"
      GenerateFullTypeName="false"
      GenerateTypeNameWithDeclaringTypeName="true"
      GenerateAttributeWithNamedArguments="false"
      GenerateStaticMembersFirst="true"
      GenerateValueWithDefaultLiteral="true"
      GenerateNullableAnnotations="$(GenerateApiList_GenerateNullableAnnotations)"
    >
      <Output TaskParameter="GeneratedFiles" ItemName="_GeneratedApiListFiles" />
    </GenerateApiList>

    <ItemGroup>
      <ApiListFiles Include="%(_GeneratedApiListFiles.Identity)">
        <SourceAssembly>%(_GeneratedApiListFiles.SourceAssembly)</SourceAssembly>
        <TargetFramework>$([System.IO.Path]::GetDirectoryName(
          $([System.IO.Path]::GetRelativePath(
            $([System.IO.Path]::GetFullPath('$(OutputPath)', '$(MSBuildProjectDirectory)')),
            '%(_GeneratedApiListFiles.SourceAssembly)'
          ))
        ))</TargetFramework>
      </ApiListFiles>
    </ItemGroup>
  </Target>

  <Target
    Name="GenerateNupkgReadmeFile"
    BeforeTargets="GenerateNuspec"
    DependsOnTargets="GenerateAPIListOfPackage"
    Condition="'$(APIListEnableGenerating)' == 'true' and '$(GeneratePackageReadmeFile)' == 'true'"
  >
    <GetLatestFramework Frameworks="$(TargetFrameworks)">
      <Output TaskParameter="LatestFramework" PropertyName="LatestTargetFramework" />
    </GetLatestFramework>

    <ItemGroup>
      <ApiListFileOfLatestFramework Include="%(ApiListFiles.Identity)" Condition="'%(ApiListFiles.TargetFramework)' == '$(LatestTargetFramework)'" />
    </ItemGroup>

    <ItemGroup>
      <NupkgReadmeLines Include="# $(Product)" />
      <NupkgReadmeLines Include="$(Description)%0A" />
      <NupkgReadmeLines Include="## API List" />
      <NupkgReadmeLines Include="List of APIs exposed by assembly `$(AssemblyName)-$(InformationalVersion)` ($(LatestTargetFramework)).%0A" />
      <NupkgReadmeLines Include="```cs" />
      <NupkgReadmeLines Include="$([System.IO.File]::ReadAllText('%(ApiListFileOfLatestFramework.Identity)'))" />
      <NupkgReadmeLines Include="```" />
    </ItemGroup>

    <WriteLinesToFile
      File="$(PackageReadmeFileOutputPath)"
      Lines="@(NupkgReadmeLines)"
      Overwrite="true"
    />
  </Target>

  <UsingTask
    TaskName="GetLatestFramework"
    TaskFactory="RoslynCodeTaskFactory"
    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll"
  >
    <ParameterGroup>
      <Frameworks ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
      <LatestFramework ParameterType="System.String" Output="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System" />
      <Using Namespace="System.Linq" />
      <Code Type="Fragment" Language="cs"><![CDATA[
        LatestFramework = Frameworks
          ?.Select(static item => item.ItemSpec)
          ?.Select(static moniker => {
            if (moniker.StartsWith("netcoreapp", StringComparison.OrdinalIgnoreCase))
              return new { Moniker = moniker, Identifier = ".NETCoreApp", Version = moniker.Substring("netcoreapp".Length) };

            if (moniker.StartsWith("netstandard", StringComparison.OrdinalIgnoreCase))
              return new { Moniker = moniker, Identifier = ".NETStandard", Version = moniker.Substring("netstandard".Length) };

            if (
              moniker.StartsWith("net4", StringComparison.OrdinalIgnoreCase) ||
              moniker.StartsWith("net3", StringComparison.OrdinalIgnoreCase) ||
              moniker.StartsWith("net2", StringComparison.OrdinalIgnoreCase) ||
              moniker.StartsWith("net1", StringComparison.OrdinalIgnoreCase)
            )
              return new { Moniker = moniker, Identifier = ".NETFramework", Version = moniker.Substring("net".Length).PadRight(3, '0') };

            if (moniker.StartsWith("net", StringComparison.OrdinalIgnoreCase))
              return new { Moniker = moniker, Identifier = ".NETCoreApp", Version = moniker.Substring("net".Length) };

            return new { Moniker = moniker, Identifier = "unknown", Version = moniker };
          })
          ?.OrderBy(static f => f.Identifier switch {
            ".NETCoreApp" => 0,
            ".NETStandard" => 1,
            ".NETFramework" => 2,
            _ => int.MaxValue,
          })
          ?.ThenByDescending(static f => f.Version)
#if false
          ?.Select(/*static*/ (f, index) => {
            Log.LogMessage(MessageImportance.High, $"#{index}: Moniker={f.Moniker}, Identifier={f.Identifier}, Version={f.Version}");
            return f;
          })
          ?.ToList()
#endif
          ?.Select(static f => f.Moniker)
          ?.First();
      ]]></Code>
    </Task>
  </UsingTask>
</Project>
