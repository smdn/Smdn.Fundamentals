// SPDX-FileCopyrightText: 2022 smdn <smdn@smdn.jp>
// SPDX-License-Identifier: MIT
using System;
#if NULL_STATE_STATIC_ANALYSIS_ATTRIBUTES
using System.Diagnostics.CodeAnalysis;
#endif
using System.Reflection;

using Smdn.Reflection.Attributes;

namespace Smdn.Reflection;

public static class FieldInfoExtensions {
  private static BindingFlags GetBindingFlagsForAutoGeneratedMember(FieldInfo f)
    => (f.IsStatic ? BindingFlags.Static : BindingFlags.Instance) | BindingFlags.Public | BindingFlags.NonPublic;

  private static bool IsAutoGeneratedField(FieldInfo f)
    => f.HasCompilerGeneratedAttribute();

  public static bool IsPropertyBackingField(this FieldInfo f)
    => TryGetPropertyFromBackingField(
      f ?? throw new ArgumentNullException(nameof(f)),
      out _
    );

  public static bool TryGetPropertyFromBackingField(
    this FieldInfo backingField,
#if NULL_STATE_STATIC_ANALYSIS_ATTRIBUTES
    [NotNullWhen(true)]
#endif
    out PropertyInfo? property
  )
  {
    property = default;

    if (
      backingField is null ||
      !IsAutoGeneratedField(backingField) ||
      backingField.DeclaringType is null
    ) {
      return false;
    }

    var propertyName = PropertyInfoExtensions.GetPropertyNameFromBackingField(backingField);

    if (propertyName is null)
      return false;

    var mayBeAutoGeneratedProperty = backingField.DeclaringType.GetProperty(
      name: propertyName,
      bindingAttr: GetBindingFlagsForAutoGeneratedMember(backingField)
    );

    if (
      mayBeAutoGeneratedProperty is not null &&
      PropertyInfoExtensions.IsAccessorAutoGenerated(mayBeAutoGeneratedProperty)
    ) {
      property = mayBeAutoGeneratedProperty;
      return true;
    }

    return false;
  }

  public static bool IsEventBackingField(this FieldInfo f)
    => TryGetEventFromBackingField(
      f ?? throw new ArgumentNullException(nameof(f)),
      out _
    );

  public static bool TryGetEventFromBackingField(
    this FieldInfo backingField,
#if NULL_STATE_STATIC_ANALYSIS_ATTRIBUTES
    [NotNullWhen(true)]
#endif
    out EventInfo? ev
  )
  {
    ev = null;

    if (
      backingField is null ||
      !IsAutoGeneratedField(backingField) ||
      backingField.DeclaringType is null
    ) {
      return false;
    }

    var mayBeAutoGeneratedEvent = backingField.DeclaringType.GetEvent(
      name: EventInfoExtensions.GetEventNameFromBackingField(backingField),
      bindingAttr: GetBindingFlagsForAutoGeneratedMember(backingField)
    );

    if (mayBeAutoGeneratedEvent is not null && EventInfoExtensions.IsAccessorAutoGenerated(mayBeAutoGeneratedEvent)) {
      ev = mayBeAutoGeneratedEvent;
      return true;
    }

    return false;
  }

  public static bool IsReadOnly(this FieldInfo f)
    => f is null
      ? throw new ArgumentNullException(nameof(f))
      : f.HasIsReadOnlyAttribute();

  /// <seealso href="https://learn.microsoft.com/dotnet/csharp/language-reference/proposals/csharp-11.0/required-members">
  /// Feature specifications - Required Members
  /// </seealso>
  public static bool IsRequired(this FieldInfo f)
  {
    if (f is null)
      throw new ArgumentNullException(nameof(f));

    // following modifiers cannot be combined with `required`
    if (f.IsStatic) // `static`
      return false;
    if (f.IsInitOnly) // `readonly`
      return false;
    if (f.IsLiteral) // `const`
      return false;
    if (f.FieldType.IsByRef) // `ref` and `ref readonly`
      return false;

    return f.HasRequiredMemberAttribute();
  }
}
